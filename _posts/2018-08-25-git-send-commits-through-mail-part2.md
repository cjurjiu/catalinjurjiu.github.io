---
title: "Git: Send commits through mail - Part 2"
excerpt_separator: "<!--more-->"
categories:
  - Git
tags:
  - Git
---

Bob considers it's worth improving on top of the [`git diff`](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1#git-diff---using-patches) approach, seeing he'll be working like this for a while.
<!--more-->

This is a multi-part series, with this being the second part. Best to start with [Part 1](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1).
There's also a Part 3 coming up.

## Recap

In the previous post we've seen how our Git-savvy consultant Bob deals with having to send work (contents of commits) 
between two machines: "Roadrunner" - his fast, snappy MacBook with no access to the project's remote repository
and "Sloth" - a terribly slow laptop received from the client, with access to the project's repository.

Given Bob's [weird situation](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1/#scenario), his plan is to 
basically code on Roadrunner, then send his work to Sloth, via corporate email. Once the code is on Sloth, perform a 
push to send the changes to the remote.

His approach until now was to use `git diff` paired with `git apply` to send the changes associated with a commit from
one machine to another, however he quickly discovered the [limitations](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1#limitations)
of this approach.

In this article, we'll see how to solve the [scalability](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1/#scalability) 
related issues.

## `git format-patch`

Basic syntax:
```shell
git format-patch <from_commit>..<up_to_commit> -o <output_folder>
```

Official Git documentation excerpt:

> Prepare each commit with its patch in one file per commit \[...\]. The output of this 
command is **convenient for e-mail submission** \[...\].

Needless to say that after reading this Bob started to feel better about himself, seeing that maybe he's not the first one 
trying to send commits via e-mail.

Basically, `git format-patch` does all of the hard work in creating patch files for one or more commits at a time. When
compared to patches created by `git diff`, the files generated by `git format-patch` additionally store **commit** 
data (commit message, author info, parent commit SHA1, commit time, etc), and not just **diff** data. Furthermore,
the resulting patch files have an ordering relation, meaning they know in which order they need to be applied.

Applying patches created by `git format-patch` will result in actual commits being made. This is possible because again,
in these patches there's all the information needed to make commits: from the commit message & time, to the order in which 
this patches need to be applied. 

This represents a *huge* improvement over the `git diff` approach which required the commits to be made manually. It also
means this is an inherently less error-prone approach, since everything is managed automatically by Git, so there's no 
need to worry about a patch being generated from the wrong commits, or about copying the wrong commit message after 
applying a patch.

### Show me some `git`

Let's assume Bob continued to work on his cool feature using Roadrunner, until `CoolFeature.java` looked like this:

{% highlight java linenos %}
Bob is a truly great developer.                        | commit#1 dc557cd
He usually writes his own code.                        | commit#2 f44f51a
If copying StackOverflow answers counts.               | commit#3 94e007a
But his lead doesn't know.                             | commit#4 6ebe293
Not that it would matter.                              | commit#5 e0e0d59
Because Bob always delivers.                           | commit#6 72ada5b (HEAD -> master)
{% endhighlight %} 

If Bob were to compare the `master` branch between Roadrunner & Sloth, it would look in the following way:

{% highlight shell %}
72ada5b commit#6 (HEAD -> Roadrunner/master) 
e0e0d59 commit#5
6ebe293 commit#4
94e007a commit#3 (HEAD -> Sloth/master) 
f44f51a commit#2
dc557cd commit#1
{% endhighlight %}

So at this point, Bob wants to send **commit#4**, **commit#5** & **commit#6** from Roadrunner to Sloth. This time, he'll
use `git format-patch` instead of `git diff` to create the patches:

```shell
git format-patch 94e007a..72ada5b -o ../patches
```
This will generate 3 patch files in the folder specified through `-o`. If the command is executed successfully, it will 
print the name of the generated files & the location where they are saved:
{% highlight shell %}
../patches/0001-commit-4.patch
../patches/0002-commit-5.patch
../patches/0003-commit-6.patch
{% endhighlight %}

If we peak inside `0001-commit-4.patch`, we'll see:

{% highlight diff linenos %}

From 6ebe293f5333943f61862fb64efce81c6850206b Mon Sep 17 00:00:00 2001
From: Bob THE Dev <bobdev@bobscorp.com>
Date: Thu, 23 Aug 2018 21:55:46 +0300
Subject: [PATCH 1/3] commit#4

---
 CoolFeature.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/CoolFeature.java b/CoolFeature.java
index 84fa290..c619c2e 100644
--- a/CoolFeature.java
+++ b/CoolFeature.java
@@ -1,3 +1,4 @@
 Bob is a truly great developer.
 He usually writes his own code.
-If copying StackOverflow answers counts.
\ No newline at end of file
+If copying StackOverflow answers counts.
+But his lead doesn't know.
\ No newline at end of file
-- 
2.16.2
{% endhighlight %}

The output looks very similar to a simple `git diff` but we can see the additional commit information (subject, time of 
commit, author identity) stored in the first part of the file.

Now, Bob sends the patches to Sloth, then to apply them he needs to use `git am`. This command can apply one patch at a
time:

```shell
 git am ../patches/0001-commit-4.patch
 Applying: commit#4
 git am ../patches/0002-commit-5.patch
 Applying: commit#5
 git am ../patches/0003-commit-6.patch
 Applying: commit#6
```

Or can apply all the patches at once if all are specified in one `am` command:

```shell
git am ../patches/0001-commit-4.patch ../patches/0002-commit-5.patch ../patches/0003-commit-6.patch
Applying: commit#4
Applying: commit#5
Applying: commit#6
```

The patches need to be specified in the correct order. Solution to this 
[later in the article](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part2#keeping-things-in-order).
{: .notice--warning}

And that's it! After the patches have been applied on Sloth, if Bob runs `git log` he will see that the commits have been
successfully applied:

```
341afa6 (HEAD -> master) commit#6
e437714 commit#5
bf32540 commit#4
94e007a commit#3
f44f51a commit#2
dc557cd commit#1
```

And that the content is as we (or Bob) expect it to be:

{% highlight java linenos %}
Bob is a truly great developer.                        | commit#1 dc557cd
He usually writes his own code.                        | commit#2 f44f51a
If copying StackOverflow answers counts.               | commit#3 94e007a
But his lead doesn't know.                             | commit#4 bf32540
Not that it would matter.                              | commit#5 e437714
Because Bob always delivers.                           | commit#6 341afa6 (HEAD -> master)
{% endhighlight %} 

#### Keeping things in order

One headache with this method, as with the `git diff` one, is the fact the you manually need to specify to `git am` the 
correct order of applying the patches, otherwise they will fail to apply.

Fortunately, this is a nuisance that can easily be fixed: save all the patches in one file. In order to do so, we need
to tell `git format-patch` a name for the file which will store the resulting patches. By just providing this name, the 
command will save all patches to the file specified file.

So assume we want to save all 3 patches generated earlier to a single file named `bobs_3_patches.patch`, in the `patches`
folder we also used earlier. The command is:
```
git format-patch 94e007a..72ada5b --stdout > ../patches/bobs_3_patches.patch
```

If we take a look into the file:

```diff
From 6ebe293f5333943f61862fb64efce81c6850206b Mon Sep 17 00:00:00 2001
From: Bob THE Dev <bobdev@bobscorp.com>
Date: Thu, 23 Aug 2018 21:55:46 +0300
Subject: [PATCH 1/3] commit#4

---
 CoolFeature.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
[...]

From e0e0d59c3a50e6015dc86ed66ed4c1ae80198ff2 Mon Sep 17 00:00:00 2001
From: Bob THE Dev <bobdev@bobscorp.com>
Date: Sat, 25 Aug 2018 14:59:23 +0300
Subject: [PATCH 2/3] commit#5

---
 CoolFeature.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
[...]

From 72ada5bbb5de5c04e7892b3b9d2b1d97a4a18076 Mon Sep 17 00:00:00 2001
From: Bob THE Dev <bobdev@bobscorp.com>
Date: Sat, 25 Aug 2018 14:59:52 +0300
Subject: [PATCH 3/3] commit#6

---
 CoolFeature.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
[...]
```

We see that all 3 patches are saved, in order, as we would expect. To keep things short, I replaced the actual diff with
`[...]`.

Now, to apply all 3 patches we only need to invoke `git am` once:
```shell
git am ../patches/bobs_3_patches.patch
Applying: commit#4
Applying: commit#5
Applying: commit#6
```
And the output will confirm that all 3 patches have been applied automatically, **in the correct order**! 
 
### Commit SHA1
Well it worked, but that's not the complete story. When compared to the original commits, we see that the commits created
by `git am` have different SHA1 Id's, although the content is the same:

```
      Roadrunner       |         Sloth
  (original commits)   |  (commits reapplied 
                       |       by git-am)
_______________________|______________________
  72ada5b commit#6     |     341afa6 commit#6 *
  e0e0d59 commit#5     |     e437714 commit#5 *
  6ebe293 commit#4     |     bf32540 commit#4 *
  94e007a commit#3     |     94e007a commit#3
  f44f51a commit#2     |     f44f51a commit#2
  dc557cd commit#1     |     dc557cd commit#1

* = Changed SHA1 relative to the original commit
```

In certain cases this can make life harder, although most of the times it might not be an issue. We'll explore these cases
in the upcoming Part 3. There, Bob will also finally find the holy grail of sending commits: a method which will also preserve the 
SHA1 of each commit.

## Conclusions

We learned about how to send commits using `git format-patch` & `git am`, a method less error-prone when compared to the
method presented in [Part 1](http://www.catalinjurjiu.com/git/git-send-commits-through-mail-part1). We also learned a cool
trick to make `git am` apply automatically all the patches in order.

However, there's one final point to solve: making sure the commits have identical SHA1 Id's on both machines. We will find
out how to achieve this, in Part 3.